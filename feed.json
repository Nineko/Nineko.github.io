{
    "version": "https://jsonfeed.org/version/1",
    "title": "Nineko's Blog",
    "description": "",
    "home_page_url": "https://nineko.github.io",
    "items": [
        {
            "id": "https://nineko.github.io/2020/08/04/Note-Multi-Scale/",
            "url": "https://nineko.github.io/2020/08/04/Note-Multi-Scale/",
            "title": "[筆記]序列模型(2)-多尺度架構",
            "date_published": "2020-08-04T03:15:06.000Z",
            "content_html": "<h1>目錄</h1>\n<p>基本序列模型</p>\n<p><strong>多尺度架構</strong></p>\n<p>捷徑架構</p>\n<h1>多尺度架構</h1>\n<hr>\n<p>  多尺度架構能夠在 GoogLeNet 中的 Inception 架構中廣泛看到，其概念想法為利用不同卷積核大小的卷積層來給予網路更多的選擇去擷取適當的特徵，在架構上，我們能夠把多尺度架構分成兩個步驟──分散及匯集；分散指的是將輸入分散至不同大小卷積核的卷積層，匯集則是將不同卷積層的結果重新組裝成一個張量，所以在進行卷積計算時，會利用 Padding 來確保輸出張量的長寬是一致的，圖解的話像是這種感覺。</p>\n<p><img src=\"M1.png\" alt=\"image\"></p>\n<p>  可以看到為了進行多尺度的計算，我們無法去操作特徵圖的長寬，這意味著龐大的參數計算，為了緩和計算負擔，我們可以利用多次卷積降低兩維的大小，將資訊累積在深度上，多尺度計算時也可以利用 1x1 的卷積核來降低深度維度，使用這些技巧來建構多尺度架構，在結果與參數使用量上取得適當的平衡吧。</p>\n<p>接下來將會用簡單的範例來示範如何建構一個多尺度架構。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> tensorflow <span class=\"keyword\">as</span> tf</span><br><span class=\"line\"><span class=\"keyword\">from</span> keras <span class=\"keyword\">import</span> backend <span class=\"keyword\">as</span> K</span><br><span class=\"line\"><span class=\"keyword\">from</span> keras.models <span class=\"keyword\">import</span> Model</span><br><span class=\"line\"><span class=\"keyword\">from</span> keras.layers <span class=\"keyword\">import</span> Conv2D,Input,concatenate</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">MultiScaleModel</span>():</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 輸入層</span></span><br><span class=\"line\">    model_input = Input(shape=(<span class=\"number\">15</span>,<span class=\"number\">15</span>,<span class=\"number\">3</span>), name=<span class=\"string\">&#x27;input&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\">#  1x1 卷積層</span></span><br><span class=\"line\">    conv1 = Conv2D(<span class=\"number\">10</span>, (<span class=\"number\">1</span>, <span class=\"number\">1</span>), activation=<span class=\"string\">&#x27;relu&#x27;</span>, padding=<span class=\"string\">&#x27;same&#x27;</span> ,name=<span class=\"string\">&#x27;Conv_1_1&#x27;</span>)(model_input)</span><br><span class=\"line\">    <span class=\"comment\">#  3x3 卷積層</span></span><br><span class=\"line\">    conv3 = Conv2D(<span class=\"number\">20</span>, (<span class=\"number\">3</span>, <span class=\"number\">3</span>), activation=<span class=\"string\">&#x27;relu&#x27;</span>, padding=<span class=\"string\">&#x27;same&#x27;</span> ,name=<span class=\"string\">&#x27;Conv_3_3&#x27;</span>)(model_input)  </span><br><span class=\"line\">    <span class=\"comment\">#  5x5 卷積層</span></span><br><span class=\"line\">    conv5 = Conv2D(<span class=\"number\">30</span>, (<span class=\"number\">5</span>, <span class=\"number\">5</span>), activation=<span class=\"string\">&#x27;relu&#x27;</span>, padding=<span class=\"string\">&#x27;same&#x27;</span> ,name=<span class=\"string\">&#x27;Conv_5_5&#x27;</span>)(model_input)</span><br><span class=\"line\">    <span class=\"comment\"># 輸出層 - 進行 concatenate</span></span><br><span class=\"line\">    model_output= concatenate([conv1, conv3, conv5] , axis=<span class=\"number\">3</span>,name=<span class=\"string\">&#x27;output&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    model = Model(inputs=[model_input], outputs=[model_output])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> model</span><br></pre></td></tr></table></figure>\n<p>使用 <code>model.summary()</code>  可以更清楚的看到架構。</p>\n<p><img src=\"M2.PNG\" alt=\"image\"></p>\n<p>這裡值得一提的是，在進行 concatenate 時，需要指定接合的維度。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">tf.keras.layers.Concatenate(axis=<span class=\"number\">-1</span>, **kwargs)</span><br></pre></td></tr></table></figure>\n<p>在這裡因為我們的卷積層輸出為 (None,15,15,10) 、 (None,15,15,20) 、 (None,15,15,30) ，需要接合的為第三維度，所以需要設定 <code>axis=3</code> ，若想了解更多資訊，可以參考 <a href=\"https://keras.io/api/layers/merging_layers/concatenate/\">Keras 手冊</a></p>\n<p>  在範例中，我們只建構了一層最簡單的多尺度架構，在使用上這樣的一層只是一個 Block ，利用堆疊這些 Block 如同在建構一般卷積層一般，更深的層數意味著更複雜的特徵組合，然而比起普通卷積，多尺度的一層中包含了不同卷積核的特徵，多層疊加下會得到更複雜的特徵，給予我們設計網路架構時多了一種思路。</p>\n",
            "tags": [
                "DNN"
            ]
        },
        {
            "id": "https://nineko.github.io/2020/08/03/Note-BasicSequenceModel/",
            "url": "https://nineko.github.io/2020/08/03/Note-BasicSequenceModel/",
            "title": "[筆記]序列模型(1)-基本序列模型",
            "date_published": "2020-08-03T07:55:22.000Z",
            "content_html": "<h1>目錄</h1>\n<p><strong>基本序列模型</strong></p>\n<p>多尺度架構</p>\n<p>捷徑架構</p>\n<h1>基本序列模型</h1>\n<hr>\n<p>  序列模型為建構深度學習網路時最直觀也最簡便的方式，在大多數時候，序列模型往往能夠讓你在解決問題上提供一個初步的解決方案。</p>\n<p>不過儘管它如此單純，依舊值得好好研究，在本篇中將會從最基本的開始說明，也就是沒有任何特別操作，單純一層疊一層的方式來建構深度學習網路。</p>\n<p>這種方式在初期被大量使用，它方便架設，也很容易理解，但是它因簡單的架構，無法處理太過於複雜的特徵，也沒有任何機制去降低計算量，可說是有利有弊。</p>\n<h2>建構</h2>\n<hr>\n<h3>全連接層</h3>\n<hr>\n<p>在這個筆記裡，範例皆為 Keras 實做版本，Keras 版本為 2.4.3 ，基底 Tensorflow 版本為 2.3.0 。</p>\n<p>假設我們想要建構一個輸入長度為 100 的向量，經過兩層輸出為 50 的隱藏層後，最後輸出長度為 10 的向量。</p>\n<p><img src=\"M1.png\" alt=\"image\"></p>\n<p>在 Keras 中，我們可以使用很簡單的方式來建構一個序列模型。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> tensorflow <span class=\"keyword\">as</span> tf</span><br><span class=\"line\"><span class=\"keyword\">from</span> keras.models <span class=\"keyword\">import</span> Model</span><br><span class=\"line\"><span class=\"keyword\">from</span> keras.layers <span class=\"keyword\">import</span> Input,Dense</span><br><span class=\"line\"><span class=\"keyword\">from</span> keras <span class=\"keyword\">import</span> backend <span class=\"keyword\">as</span> K</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">SequenceModel</span>():</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 輸入層</span></span><br><span class=\"line\">    model_input = Input(shape=(<span class=\"number\">100</span>), name=<span class=\"string\">&#x27;input&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\"># 隱藏層 1 </span></span><br><span class=\"line\">    hidden = Dense(<span class=\"number\">50</span>, activation=<span class=\"string\">&#x27;sigmoid&#x27;</span>,name=<span class=\"string\">&quot;hidden_1&quot;</span>)(model_input)</span><br><span class=\"line\">    <span class=\"comment\"># 隱藏層 2 </span></span><br><span class=\"line\">    hidden = Dense(<span class=\"number\">50</span>, activation=<span class=\"string\">&#x27;sigmoid&#x27;</span>,name=<span class=\"string\">&quot;hidden_2&quot;</span>)(hidden)</span><br><span class=\"line\">    <span class=\"comment\"># 輸出層 </span></span><br><span class=\"line\">    model_output = Dense(<span class=\"number\">10</span>, activation=<span class=\"string\">&#x27;sigmoid&#x27;</span>,name=<span class=\"string\">&quot;output&quot;</span>)(hidden)</span><br><span class=\"line\"></span><br><span class=\"line\">    model = Model(inputs=[model_input], outputs=[model_output])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> model</span><br></pre></td></tr></table></figure>\n<p>  可以看到由 Keras 建構只需要專心建構網路的架構，而不需要做 Weight 及 Bias 的數量及初始化定義，它會以預設的參數進行建構，若要修改也可以帶入引數進行設定。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">keras.layers.Dense(units, </span><br><span class=\"line\">                   activation=<span class=\"literal\">None</span>, </span><br><span class=\"line\">                   use_bias=<span class=\"literal\">True</span>, </span><br><span class=\"line\">                   kernel_initializer=<span class=\"string\">&#x27;glorot_uniform&#x27;</span>, bias_initializer=<span class=\"string\">&#x27;zeros&#x27;</span>, </span><br><span class=\"line\">                   kernel_regularizer=<span class=\"literal\">None</span>, </span><br><span class=\"line\">                   bias_regularizer=<span class=\"literal\">None</span>, </span><br><span class=\"line\">                   activity_regularizer=<span class=\"literal\">None</span>, </span><br><span class=\"line\">                   kernel_constraint=<span class=\"literal\">None</span>, </span><br><span class=\"line\">                   bias_constraint=<span class=\"literal\">None</span>)</span><br></pre></td></tr></table></figure>\n<p>若要了解更詳細的設定可以查看 <a href=\"https://keras.io/api/layers/core_layers/dense/\">Keras 手冊</a></p>\n<h3>卷積層</h3>\n<hr>\n<p>  若要建構一個 DNN ，卷積層是必須的，與全連接層相同的做法，只是呼叫的函式不同而已。</p>\n<p>  在接下來的範例中，輸入張量為 100x100x3 ，經過兩層 50 個卷積核為 3x3 ，Stride 為 2 ，不使用 Padding 的卷積層後，進行 Flatten ，最後再接入向量長度為 10 的輸出層。</p>\n<p><img src=\"M2.png\" alt=\"image\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> tensorflow <span class=\"keyword\">as</span> tf</span><br><span class=\"line\"><span class=\"keyword\">from</span> keras.models <span class=\"keyword\">import</span> Model</span><br><span class=\"line\"><span class=\"keyword\">from</span> keras.layers <span class=\"keyword\">import</span> Input,Dense,Conv2D</span><br><span class=\"line\"><span class=\"keyword\">from</span> keras <span class=\"keyword\">import</span> backend <span class=\"keyword\">as</span> K</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">SequenceModel</span>():</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># 輸入層</span></span><br><span class=\"line\">    model_input = Input(shape=(<span class=\"number\">100</span>,<span class=\"number\">100</span>,<span class=\"number\">3</span>), name=<span class=\"string\">&#x27;input&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\"># 隱藏層 1 </span></span><br><span class=\"line\">    hidden = Conv2D(<span class=\"number\">50</span>, (<span class=\"number\">3</span>, <span class=\"number\">3</span>), activation=<span class=\"string\">&#x27;relu&#x27;</span>, padding=<span class=\"string\">&#x27;valid&#x27;</span>,name=<span class=\"string\">&#x27;hidden_1&#x27;</span>)(model_input)</span><br><span class=\"line\">    <span class=\"comment\"># 隱藏層 2 </span></span><br><span class=\"line\">    hidden = Conv2D(<span class=\"number\">50</span>, (<span class=\"number\">3</span>, <span class=\"number\">3</span>), activation=<span class=\"string\">&#x27;relu&#x27;</span>, padding=<span class=\"string\">&#x27;valid&#x27;</span>,name=<span class=\"string\">&#x27;hidden_2&#x27;</span>)(model_input)</span><br><span class=\"line\">    <span class=\"comment\"># Flatten</span></span><br><span class=\"line\">    Flatten_layer = Flatten(name=<span class=\"string\">&#x27;flatten&#x27;</span>)(hidden)</span><br><span class=\"line\">    <span class=\"comment\"># 輸出層 </span></span><br><span class=\"line\">    model_output = Dense(<span class=\"number\">10</span>, activation=<span class=\"string\">&#x27;sigmoid&#x27;</span>,name=<span class=\"string\">&quot;output&quot;</span>)(Flatten_layer)</span><br><span class=\"line\"></span><br><span class=\"line\">    model = Model(inputs=[model_input], outputs=[model_output])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> model</span><br></pre></td></tr></table></figure>\n<p>同樣，這只是最基本的應用，若要更進階的使用請詳看 <a href=\"https://keras.io/api/layers/convolution_layers/\">Keras 手冊</a></p>\n<p>  以上，我們已經知道該怎麼建構卷積層及全連接層，使用這兩者已經可以建構一個影像辨識的應用，像是一開始的 AlexNet 及 VGG 系列都是使用單純的卷積加上全連接層建構而成的，接下來，你可以建構自己的架構嘗試進行影像辨識，可以使用<a href=\"http://yann.lecun.com/exdb/mnist/\">手寫辨識 MINST</a> 或是 <a href=\"https://www.kaggle.com/c/dogs-vs-cats\">Kaggle 的 Dogs v.s Cats</a> 進行練習。</p>\n",
            "tags": [
                "DNN"
            ]
        },
        {
            "id": "https://nineko.github.io/2020/07/30/MyPaper/",
            "url": "https://nineko.github.io/2020/07/30/MyPaper/",
            "title": "Training Deep Networks with Synthetic Data for Textureless Object Pose Estimation",
            "date_published": "2020-07-30T08:22:33.000Z",
            "content_html": "<p>碩士研究成果，不過目前因其他因素，無法公開全文，也不適合作太詳細的說明，還請見諒<br>\n最晚公開時間 2025.01</p>\n<h1>論文連結</h1>  \n<p><a href=\"https://drive.google.com/open?id=14RATn-h3gV4wIrBbZ2rxjERyxK64EEQM\">https://drive.google.com/open?id=14RATn-h3gV4wIrBbZ2rxjERyxK64EEQM</a><br>\n<a href=\"https://github.com/Nineko/Deep-Learning_Training-Deep-Networks-with-Synthetic-Data-for-Textureless\">Github Link</a></p>\n<h1>簡述</h1>\n<h2>問題定義</h2>\n<p>在這個研究中想要解決在工業應用上因傳統視覺伺服的不足而導入深度學習時，所發生的種種問題。<br>\n我們假設視覺系統為一個手眼系統 (左圖)，所以能夠以物體為圓心定義出一個球座標系 (右圖)</p>\n<p><img src=\"eyeonhand.png\" alt=\"image\"></p>\n<p>根據此座標系，在我們的研究中主要考慮三個變量 : In-plane Rotation 、 Theta 、 Phi</p>\n<p><img src=\"ThreePara.gif\" alt=\"image\"></p>\n<h2>CAD Simulator</h2>\n<p>同時為了解決訓練資料取得及標定不易的問題，我們撰寫了使用 OpenGL 並在 QT 上進行開發的 CAD 模型模擬器，詳細可以前往我的 CAD-Simulator 專案 (<a href=\"https://github.com/Nineko/CAD-Simulator\">https://github.com/Nineko/CAD-Simulator</a>)</p>\n<p><img src=\"CAD%E6%A8%A1%E5%9E%8B%E7%95%8C%E9%9D%A2.png\" alt=\"image\"></p>\n<h2>測試結果</h2>\n<p>在本研究中，我們利用前述的模擬器產生訓練資料進行訓練，並以相同的方式產生測試集對三種物體進行測試，每種物體都產生了約 16000 張圖片進行測試</p>\n<p><img src=\"class.jpg\" alt=\"image\"></p>\n<p>測試時分成兩個部分，首先為分辨物體及物體定位的結果 :</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Class</th>\n<th style=\"text-align:center\">Mean IoU</th>\n<th style=\"text-align:center\">Mean Classification Accuracy</th>\n<th style=\"text-align:center\">Center X-Shift Error (By pixel)</th>\n<th style=\"text-align:center\">Center Y-Shift Error (By pixel)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Class 1</td>\n<td style=\"text-align:center\">0.8824</td>\n<td style=\"text-align:center\">0.8284</td>\n<td style=\"text-align:center\">2.3140</td>\n<td style=\"text-align:center\">2.2287</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Class 2</td>\n<td style=\"text-align:center\">0.8592</td>\n<td style=\"text-align:center\">0.8496</td>\n<td style=\"text-align:center\">1.6883</td>\n<td style=\"text-align:center\">1.6435</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Class 3</td>\n<td style=\"text-align:center\">0.9362</td>\n<td style=\"text-align:center\">0.8499</td>\n<td style=\"text-align:center\">1.9301</td>\n<td style=\"text-align:center\">1.6057</td>\n</tr>\n</tbody>\n</table>\n<p>再來是三個變量的估測結果 :</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Class</th>\n<th style=\"text-align:center\">Mean In-plane rotation error(°)</th>\n<th style=\"text-align:center\">Mean Theta error(°)</th>\n<th style=\"text-align:center\">Mean Phi error(°)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">Class 1</td>\n<td style=\"text-align:center\">2.7461</td>\n<td style=\"text-align:center\">1.3171</td>\n<td style=\"text-align:center\">6.2603</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Class 2</td>\n<td style=\"text-align:center\">3.5969</td>\n<td style=\"text-align:center\">0.8520</td>\n<td style=\"text-align:center\">6.2455</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Class 3</td>\n<td style=\"text-align:center\">4.6340</td>\n<td style=\"text-align:center\">1.0070</td>\n<td style=\"text-align:center\">6.0381</td>\n</tr>\n</tbody>\n</table>\n",
            "tags": [
                "DNN",
                "Computer Vision",
                "Pose Estimation"
            ]
        },
        {
            "id": "https://nineko.github.io/2020/07/30/CAD-Simulator/",
            "url": "https://nineko.github.io/2020/07/30/CAD-Simulator/",
            "title": "CAD Simulator",
            "date_published": "2020-07-30T05:00:15.000Z",
            "content_html": "<p>讀取.dxf 檔案格式，產生渲染合成影像作訓練資料使用</p>\n<p>[*]Develop in QT5.9<br>\n<a href=\"https://github.com/Nineko/CAD-Simulator\">Github Link</a></p>\n<p><img src=\"clamp.png\" alt=\"image\"></p>\n<h1>虛擬相機以球座標系定義</h1>\n<p>物體於圓心，虛擬相機的位置將由 1) 物體與相機距離 <code>r</code>  2) 天頂角 <code>Theta</code>  3) 方位角 <code>Phi</code>  三個參數來設定<br>\n<img src=\"%E7%90%83%E5%BA%A7%E6%A8%99%E7%B3%BB.png\" alt=\"image\"></p>\n<h1>整體介面</h1>\n<p>可變參數</p>\n<ul>\n<li>Theta angle</li>\n<li>Phi angle</li>\n<li>In-plane rotate angle</li>\n<li>Camera shift(x/y direction)</li>\n<li>Light direction</li>\n<li>batch process setting<br>\n<img src=\"CAD_UI.png\" alt=\"image\"></li>\n</ul>\n",
            "tags": [
                "QT"
            ]
        },
        {
            "id": "https://nineko.github.io/2020/07/30/School-Project-PSO/",
            "url": "https://nineko.github.io/2020/07/30/School-Project-PSO/",
            "title": "[School Project] Particle Swarm Optimization",
            "date_published": "2020-07-30T04:44:44.000Z",
            "content_html": "<p>This program simulates the process which finding the best solution of the Ackley function with particle swarm optimization method</p>\n<p>[*]Develop in qt5.9<br>\n<a href=\"https://github.com/Nineko/School-Project_Particle-Swarm-Optimization\">Github Link</a></p>\n<h1>Object function : Ackley function</h1>\n<p><img src=\"equ.png\" alt=\"image\"><br>\n<img src=\"Demo.gif\" alt=\"image\"></p>\n<h1>Configures</h1>\n<ul>\n<li>The number of partical : (Dedault) 30</li>\n<li>Inertia weight : (Dedault) 0.5</li>\n<li>Personal influence : (Dedault) 0.5</li>\n<li>Social influence : (Dedault) 0.5</li>\n<li>Group size : (Dedault) 10</li>\n<li>Termination condition : (Dedault) 0.000001</li>\n</ul>\n<p><img src=\"config.png\" alt=\"image\"></p>\n",
            "tags": [
                "QT"
            ]
        },
        {
            "id": "https://nineko.github.io/2020/07/30/School-Project-Genetic-Algorithm/",
            "url": "https://nineko.github.io/2020/07/30/School-Project-Genetic-Algorithm/",
            "title": "[School Project] Genetic Algorithm",
            "date_published": "2020-07-30T03:20:36.000Z",
            "content_html": "<p>This program simulates the process which finding the best solution of the Ackley function with genetic algorithm</p>\n<p>[*]Develop in qt5.9<br>\n<a href=\"https://github.com/Nineko/School-Project_Genetic-Algorithm\">Github Link</a></p>\n<h1>Object function : Ackley function</h1>\n<p><img src=\"equ.png\" alt=\"\"></p>\n<h1>Configures</h1>\n<ul>\n<li>Initial population size: (Dedault) 50</li>\n<li>Probability of performing crossover : (Dedault) 1.0</li>\n<li>Probability of mutation : (Dedault) 0.5</li>\n<li>Decode mode : binary / real</li>\n<li>Crossover mode : single / double / multiple</li>\n<li>Pooling size : (Dedault) 40</li>\n</ul>\n<p><img src=\"conf.png\" alt=\"\"></p>\n",
            "tags": [
                "QT"
            ]
        }
    ]
}